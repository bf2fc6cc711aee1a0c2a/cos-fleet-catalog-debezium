{
  "connector_type" : {
    "id" : "debezium-mongodb",
    "kind" : "ConnectorType",
    "href" : "/api/connector_mgmt/v1/kafka_connector_types/debezium-mongodb-2.0.1.Final",
    "name" : "Debezium MongoDB Connector",
    "version" : "2.0.1.Final",
    "channels" : [ "stable" ],
    "description" : null,
    "labels" : [ "source", "debezium", "mongodb", "2.0.1.Final" ],
    "capabilities" : [ "data_shape" ],
    "icon_href" : "http://example.com/images/debezium-mongodb-2.0.1.Final.png",
    "schema" : {
      "title" : "Debezium MongoDB Connector",
      "required" : [ "topic.prefix" ],
      "type" : "object",
      "properties" : {
        "topic.prefix" : {
          "title" : "Topic prefix",
          "description" : "Topic prefix that identifies and provides a namespace for the particular database server/cluster is capturing changes. The topic prefix should be unique across all other connectors, since it is used as a prefix for all Kafka topic names that receive events emitted by this connector. Only alphanumeric characters, hyphens, dots and underscores must be accepted.",
          "type" : "string",
          "nullable" : false,
          "x-name" : "topic.prefix",
          "x-category" : "CONNECTION"
        },
        "mongodb.hosts" : {
          "format" : "list,regex",
          "title" : "Hosts",
          "description" : "The hostname and port pairs (in the form 'host' or 'host:port') of the MongoDB server(s) in the replica set.",
          "type" : "string",
          "x-name" : "mongodb.hosts",
          "x-category" : "CONNECTION"
        },
        "mongodb.user" : {
          "title" : "User",
          "description" : "Database user for connecting to MongoDB, if necessary.",
          "type" : "string",
          "x-name" : "mongodb.user",
          "x-category" : "CONNECTION"
        },
        "mongodb.password" : {
          "title" : "Password",
          "description" : "Password to be used when connecting to MongoDB, if necessary.",
          "oneOf" : [ {
            "format" : "password",
            "description" : "Password of the database user to be used when connecting to the database.",
            "type" : "string"
          }, {
            "description" : "An opaque reference to the password.",
            "type" : "object",
            "properties" : { },
            "additionalProperties" : true
          } ],
          "x-name" : "mongodb.password",
          "x-category" : "CONNECTION"
        },
        "mongodb.ssl.enabled" : {
          "title" : "Enable SSL connection to MongoDB",
          "description" : "Should connector use SSL to connect to MongoDB instances",
          "default" : false,
          "type" : "boolean",
          "x-name" : "mongodb.ssl.enabled",
          "x-category" : "CONNECTION_ADVANCED_SSL"
        },
        "mongodb.authsource" : {
          "title" : "Credentials Database",
          "description" : "Database containing user credentials.",
          "default" : "admin",
          "type" : "string",
          "x-name" : "mongodb.authsource",
          "x-category" : "CONNECTION_ADVANCED"
        },
        "database.include.list" : {
          "format" : "list,regex",
          "title" : "Include Databases",
          "description" : "A comma-separated list of regular expressions that match the database names for which changes are to be captured",
          "type" : "string",
          "x-name" : "database.include.list",
          "x-category" : "FILTERS"
        },
        "database.exclude.list" : {
          "format" : "list,regex",
          "title" : "Exclude Databases",
          "description" : "A comma-separated list of regular expressions that match the database names for which changes are to be excluded",
          "type" : "string",
          "x-name" : "database.exclude.list",
          "x-category" : "FILTERS"
        },
        "collection.include.list" : {
          "format" : "list,regex",
          "title" : "Include Collections",
          "description" : "A comma-separated list of regular expressions that match the collection names for which changes are to be captured",
          "type" : "string",
          "x-name" : "collection.include.list",
          "x-category" : "FILTERS"
        },
        "collection.exclude.list" : {
          "description" : "A comma-separated list of regular expressions that match the collection names for which changes are to be excluded",
          "type" : "string",
          "x-name" : "collection.exclude.list",
          "x-category" : "FILTERS"
        },
        "field.exclude.list" : {
          "title" : "Exclude Fields",
          "description" : "A comma-separated list of the fully-qualified names of fields that should be excluded from change event message values",
          "type" : "string",
          "x-name" : "field.exclude.list",
          "x-category" : "FILTERS"
        },
        "snapshot.mode" : {
          "title" : "Snapshot mode",
          "description" : "The criteria for running a snapshot upon startup of the connector. Options include: 'initial' (the default) to specify the connector should always perform an initial sync when required; 'never' to specify the connector should never perform an initial sync ",
          "default" : "initial",
          "enum" : [ "never", "initial" ],
          "type" : "string",
          "x-name" : "snapshot.mode",
          "x-category" : "CONNECTOR_SNAPSHOT"
        },
        "query.fetch.size" : {
          "format" : "int32",
          "title" : "Query fetch size",
          "description" : "The maximum number of records that should be loaded into memory while streaming. A value of '0' uses the default JDBC fetch size.",
          "default" : 0,
          "type" : "integer",
          "x-name" : "query.fetch.size",
          "x-category" : "ADVANCED"
        },
        "max.batch.size" : {
          "format" : "int32",
          "title" : "Change event batch size",
          "description" : "Maximum size of each batch of source records. Defaults to 2048.",
          "default" : 2048,
          "type" : "integer",
          "x-name" : "max.batch.size",
          "x-category" : "ADVANCED"
        },
        "max.queue.size" : {
          "format" : "int32",
          "title" : "Change event buffer size",
          "description" : "Maximum size of the queue for change events read from the database log but not yet recorded or forwarded. Defaults to 8192, and should always be larger than the maximum batch size.",
          "default" : 8192,
          "type" : "integer",
          "x-name" : "max.queue.size",
          "x-category" : "ADVANCED"
        },
        "data_shape" : {
          "type" : "object",
          "additionalProperties" : false,
          "properties" : {
            "key" : {
              "title" : "Kafka Message Key Format",
              "description" : "The serialization format for the Kafka message key.",
              "x-name" : "data_shape.key",
              "x-category" : "CONNECTOR",
              "$ref" : "#/$defs/serializer"
            },
            "value" : {
              "title" : "Kafka Message Value Format",
              "description" : "The serialization format for the Kafka message value.",
              "x-name" : "data_shape.value",
              "x-category" : "CONNECTOR",
              "$ref" : "#/$defs/serializer"
            }
          }
        },
        "processors" : {
          "type" : "array",
          "items" : {
            "oneOf" : [ {
              "title" : "Cast Kafka message key or value",
              "description" : "Cast entire Kafka message key or value to another data type.",
              "type" : "object",
              "required" : [ "cast_message" ],
              "additionalProperties" : false,
              "properties" : {
                "cast_message" : {
                  "type" : "object",
                  "required" : [ "apply_to", "cast_to" ],
                  "additionalProperties" : false,
                  "properties" : {
                    "apply_to" : {
                      "$ref" : "#/$defs/apply_to"
                    },
                    "cast_to" : {
                      "title" : "Target data type",
                      "description" : "The target data type to cast to.",
                      "$ref" : "#/$defs/kafka_connect_types"
                    }
                  }
                }
              }
            }, {
              "title" : "Cast payload fields",
              "description" : "Cast specific field/s in a Kafka message key or value to another data type.",
              "type" : "object",
              "required" : [ "cast_fields" ],
              "additionalProperties" : false,
              "properties" : {
                "cast_fields" : {
                  "type" : "object",
                  "required" : [ "apply_to", "fields" ],
                  "additionalProperties" : false,
                  "properties" : {
                    "apply_to" : {
                      "$ref" : "#/$defs/apply_to"
                    },
                    "fields" : {
                      "title" : "Fields",
                      "description" : "List of field names in the payload which values should be cast and the target data type.",
                      "type" : "array",
                      "items" : {
                        "type" : "object",
                        "required" : [ "field_name", "cast_to" ],
                        "additionalProperties" : false,
                        "properties" : {
                          "field_name" : {
                            "title" : "Field name",
                            "description" : "The name of the field in the payload which value should be cast to another data type.",
                            "type" : "string"
                          },
                          "cast_to" : {
                            "title" : "Target type",
                            "description" : "The target data type to cast to.",
                            "$ref" : "#/$defs/kafka_connect_types"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }, {
              "title" : "Cast payload fields",
              "description" : "Cast specific field/s in a Kafka message key or value to another data type.",
              "type" : "object",
              "required" : [ "insert_static_field" ],
              "additionalProperties" : false,
              "properties" : {
                "insert_static_field" : {
                  "additionalProperties" : false,
                  "required" : [ "apply_to", "field_name", "value" ],
                  "properties" : {
                    "apply_to" : {
                      "$ref" : "#/$defs/apply_to"
                    },
                    "field_name" : {
                      "$ref" : "#/$defs/insert_field_name"
                    },
                    "value" : {
                      "type" : "string"
                    }
                  }
                }
              }
            }, {
              "title" : "Insert Kafka metadata field",
              "description" : "Insert a field to the payload with Kafka record metadata as value (topic name, partition number, or message timestamp).",
              "type" : "object",
              "required" : [ "insert_kafka_field" ],
              "additionalProperties" : false,
              "properties" : {
                "insert_kafka_field" : {
                  "additionalProperties" : false,
                  "required" : [ "apply_to", "kafka_value", "field_name" ],
                  "properties" : {
                    "apply_to" : {
                      "$ref" : "#/$defs/apply_to"
                    },
                    "kafka_value" : {
                      "title" : "Kafka record metadata type",
                      "description" : "Choose which Kafka record metadata should be used as value for the inserted field (topic name, partition number, or message timestamp).",
                      "type" : "string",
                      "enum" : [ "topic name", "partition number", "message timestamp" ]
                    },
                    "field_name" : {
                      "$ref" : "#/$defs/insert_field_name"
                    }
                  }
                }
              }
            }, {
              "title" : "Filter or rename fields",
              "description" : "Filter out (excludes) or only pass (includes) specified fields in the payload, and/or rename field names.",
              "type" : "object",
              "required" : [ "filter_fields" ],
              "additionalProperties" : false,
              "properties" : {
                "filter_fields" : {
                  "additionalProperties" : false,
                  "required" : [ "apply_to" ],
                  "anyOf" : [ {
                    "required" : [ "includes" ]
                  }, {
                    "required" : [ "excludes" ]
                  }, {
                    "required" : [ "rename_fields" ]
                  } ],
                  "properties" : {
                    "apply_to" : {
                      "$ref" : "#/$defs/apply_to"
                    },
                    "includes" : {
                      "title" : "Included fields",
                      "description" : "List of field names that should pass filtering. When set, fields that are not included in this list will be filtered out / removed from the payload. Mind that excludes have precedence over the included fields!",
                      "$ref" : "#/$defs/include_exclude_list"
                    },
                    "excludes" : {
                      "title" : "Excluded fields",
                      "description" : "List of field names that should not pass filtering. When set, fields that are excluded will be filtered out / removed from the payload. Excludes have precedence over the include list!",
                      "$ref" : "#/$defs/include_exclude_list"
                    },
                    "rename_fields" : {
                      "title" : "Rename fields",
                      "description" : "Rename fields in the payload.",
                      "type" : "array",
                      "items" : {
                        "type" : "object",
                        "required" : [ "old_name", "new_name" ],
                        "additionalProperties" : false,
                        "properties" : {
                          "old_name" : {
                            "title" : "Old field name",
                            "description" : "The old field name in the payload that should be renamed.",
                            "type" : "string"
                          },
                          "new_name" : {
                            "title" : "New field name",
                            "description" : "The new name of the field.",
                            "type" : "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }, {
              "title" : "Mask fields",
              "description" : "Mask specified field/s with a valid null value for the field type (0, false, empty string, etc), or with an optional replacement value for numeric and string fields.",
              "type" : "object",
              "required" : [ "mask_fields" ],
              "additionalProperties" : false,
              "properties" : {
                "mask_fields" : {
                  "additionalProperties" : false,
                  "required" : [ "apply_to", "fields" ],
                  "properties" : {
                    "apply_to" : {
                      "$ref" : "#/$defs/apply_to"
                    },
                    "fields" : {
                      "title" : "Fields",
                      "description" : "Fields in the payload which values should be replaced with <code>replacement</code> or with a valid null value for the field type (i.e. 0, false, empty string, and so on) when no replacement is set.",
                      "type" : "array",
                      "items" : {
                        "type" : "string"
                      }
                    },
                    "replacement" : {
                      "title" : "Replacement",
                      "description" : "When set, the given fields are replaced with this value that is converted to the correct type. Else with a valid null value for the field type (i.e. 0, false, empty string, and so on).",
                      "type" : "string"
                    }
                  }
                }
              }
            }, {
              "title" : "Extract field",
              "description" : "Extract a field from the message's key or value payload and replace the whole key or value with its value.",
              "type" : "object",
              "required" : [ "extract_field" ],
              "additionalProperties" : false,
              "properties" : {
                "extract_field" : {
                  "additionalProperties" : false,
                  "required" : [ "apply_to", "field" ],
                  "properties" : {
                    "apply_to" : {
                      "$ref" : "#/$defs/apply_to"
                    },
                    "field" : {
                      "title" : "Field to extract",
                      "description" : "Name of the field that gets extracted from the payload and which value will replace the entire key or value.",
                      "type" : "string"
                    }
                  }
                }
              }
            }, {
              "title" : "Message key from fields",
              "description" : "Replace the message key with one or more fields from the message's value payload.",
              "type" : "object",
              "required" : [ "key_from_value_fields" ],
              "additionalProperties" : false,
              "properties" : {
                "key_from_value_fields" : {
                  "additionalProperties" : false,
                  "required" : [ "fields" ],
                  "properties" : {
                    "fields" : {
                      "title" : "Value fields for new key",
                      "description" : "Name of the fields that will be used to replace the message key.",
                      "type" : "array",
                      "items" : {
                        "type" : "string"
                      }
                    }
                  }
                }
              }
            }, {
              "type" : "object",
              "title" : "Simple Debezium Topic Router (not enforcing message key uniqueness)",
              "description" : "Simple Debezium Topic Router for sending change events from multiple physical tables to one topic without enforcing message key uniqueness. See: <a href=\"https://debezium.io/documentation/reference/transformations/topic-routing.html\">Topic Routing section</a> in the Debezium docs.",
              "required" : [ "debezium_topic_router_simple" ],
              "additionalProperties" : false,
              "properties" : {
                "debezium_topic_router_simple" : {
                  "additionalProperties" : false,
                  "required" : [ "topic_regex", "output_topic" ],
                  "properties" : {
                    "topic_regex" : {
                      "title" : "Input topic regex",
                      "description" : "A regular expression on the topic name of each message that determines if it should be routed to a another destination topic and captures one or more groups of characters to be applied in <code>output_topic</code>",
                      "type" : "string",
                      "format" : "regex"
                    },
                    "output_topic" : {
                      "title" : "Output topic",
                      "description" : "A regular expression replacement string that defines the destination topic name based on the captured groups from <code>topic_regex</code> .",
                      "type" : "string"
                    }
                  }
                }
              }
            }, {
              "type" : "object",
              "title" : "Unique Key Debezium Topic Router (enforcing message key uniqueness)",
              "description" : "Debezium Topic Router for sending change events from multiple physical tables to a specific topic and enforcing message key uniqueness. See: <a href=\"https://debezium.io/documentation/reference/transformations/topic-routing.html\">Topic Routing section</a> in the Debezium docs.",
              "required" : [ "debezium_topic_router_unique_keys" ],
              "additionalProperties" : false,
              "properties" : {
                "debezium_topic_router_unique_keys" : {
                  "additionalProperties" : false,
                  "required" : [ "topic_regex", "output_topic", "key_field_name" ],
                  "properties" : {
                    "topic_regex" : {
                      "title" : "Input topic regex",
                      "description" : "A regular expression on the original/input destination topic name of each message that determines if it should be routed to a another destination topic and captures one or more groups of characters to be applied in <code>output_topic</code>",
                      "type" : "string",
                      "format" : "regex"
                    },
                    "output_topic" : {
                      "title" : "Output topic",
                      "description" : "A regular expression replacement string that defines the destination topic name based on the captured groups from <code>topic_regex</code> .",
                      "type" : "string"
                    },
                    "key_field_name" : {
                      "title" : "Key field name",
                      "description" : "Name of the field to be added to the message key. The value of this field identifies the original table name using the original/input destination topic name and can optionally be manipulated with <code>key_field_topic_regex</code> and <code>key_field_value</code>.",
                      "type" : "string",
                      "default" : "__dbz__physicalTableIdentifier"
                    },
                    "key_field_topic_regex" : {
                      "title" : "Key field topic regex",
                      "description" : "Regular expression that gets applied on the original/input destination topic name to capture one or more groups of characters and then apply them in <code>key_field_value</code>",
                      "type" : "string",
                      "format" : "regex",
                      "default" : "(.*)"
                    },
                    "key_field_value" : {
                      "title" : "Key field value",
                      "description" : "A regular expression replacement string that sets the value of the inserted key field based on the captured groups from <code>key_field_topic_regex</code>.",
                      "type" : "string",
                      "default" : "$1"
                    }
                  }
                }
              }
            }, {
              "title" : "Convert to upsert record (extract new record state)",
              "description" : "Convert the complex Debezium data format into a flat upsert record. This transformation will remove the Debezium \"envelope\" with its metadata from the message and will only keep the updated dataset/row.",
              "type" : "object",
              "required" : [ "convert_to_upsert" ],
              "additionalProperties" : false,
              "properties" : {
                "convert_to_upsert" : {
                  "additionalProperties" : false,
                  "required" : [ "delete_handling_mode" ],
                  "properties" : {
                    "delete_handling_mode" : {
                      "title" : "Handle DELETE events",
                      "description" : "When set to \"tombstone\" for each DELETE operation a tombstone record will be send to Kafka. When set to \"drop\" DELETE event records will be removed from the stream and not send to Kafka.",
                      "type" : "string",
                      "default" : "tombstone",
                      "enum" : [ "tombstone", "drop" ]
                    },
                    "add_metadata_to_value" : {
                      "title" : "Add Debezium metadata to the Kafka message value",
                      "description" : "Optionally select Debezium metadata that should be added to the Kafka message value as additional fields of the payload.",
                      "$ref" : "#/$defs/debezium_metadata"
                    },
                    "metadata_value_prefix" : {
                      "$ref" : "#/$defs/debezium_metadata_prefix"
                    },
                    "add_metadata_to_headers" : {
                      "title" : "Add Debezium metadata to Kafka message headers",
                      "description" : "Optionally select Debezium metadata that should be added to the Kafka message headers as additional header fields.",
                      "$ref" : "#/$defs/debezium_metadata"
                    },
                    "metadata_headers_prefix" : {
                      "$ref" : "#/$defs/debezium_metadata_prefix"
                    }
                  }
                }
              }
            } ]
          }
        }
      },
      "additionalProperties" : true,
      "x-connector-id" : "mongodb",
      "x-version" : "2.0.1.Final",
      "x-className" : "io.debezium.connector.mongodb.MongoDbConnector",
      "$defs" : {
        "serializer" : {
          "type" : "string",
          "enum" : [ "JSON", "JSON without schema" ],
          "default" : "JSON"
        },
        "insert_field_name" : {
          "title" : "Field name",
          "description" : "The name of the field to insert. Suffix with <code>!</code> to make this a required/mandatory field, or <code>?</code> to keep it optional.",
          "type" : "string"
        },
        "apply_to" : {
          "title" : "Apply to",
          "description" : "Apply transformation to Kafka message key or message value.",
          "type" : "string",
          "enum" : [ "message key", "message value" ]
        },
        "kafka_connect_types" : {
          "type" : "string",
          "enum" : [ "string", "int8", "int16", "int32", "int64", "float32", "float64", "boolean" ]
        },
        "include_exclude_list" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        },
        "debezium_topic_router" : {
          "type" : "object",
          "additionalProperties" : false,
          "required" : [ "topic", "replacement" ],
          "properties" : {
            "topic" : {
              "type" : "string",
              "format" : "regex"
            },
            "replacement" : {
              "type" : "string",
              "format" : "regex"
            }
          }
        },
        "debezium_metadata" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "enum" : [ "op", "ts_ms", "source.ts_ms", "source.version", "source.connector", "source.db", "source.snapshot" ]
          }
        },
        "debezium_metadata_prefix" : {
          "title" : "Metadata field name prefix",
          "description" : "Optional prefix for the added Debezium metadata fields.",
          "type" : "string",
          "default" : "__"
        }
      }
    }
  },
  "channels" : {
    "stable" : {
      "shard_metadata" : {
        "connector_revision" : 2,
        "operators" : [ {
          "type" : "debezium-connector-operator",
          "version" : "[1.0.0,2.0.0)"
        } ],
        "connector_type" : "source",
        "connector_class" : "io.debezium.connector.mongodb.MongoDbConnector",
        "container_image" : "quay.io/rhoas/cos-connector-debezium-mongodb@sha256:343bb1f834d1a7424e1ff52f773bce77b1d0672724f005546d76c5b202e5b333"
      }
    }
  }
}